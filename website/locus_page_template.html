<!DOCTYPE html>
<html>
    {% include "header_template.html" %}
<body>

<div class="ui stackable grid">
    <div class="ui row" id="header-stripe">
        <div class="three wide column" class="page-grid-margin" style="padding: 0px !important"></div>
        <div class="three wide column" id="header-title">
            <a href="/">
                <img src="tandem-repeat-explorer-logo-white.png" alt="TRExplorer Logo" style="height: 40px; margin-left: 10px;">
            </a>
        </div>
        <div class="seven wide column" id="header-nav">
            <a href="#" id="about-link">About</a>
            <a href="#" id="whats-new-link" style="white-space: nowrap">What's New</a>
            <a href="#" id="faq-link">FAQ</a>
            <a href="#" id="downloads-link">Downloads</a>
            <a href="https://github.com/broadinstitute/TRExplorer/issues" target="_blank">Issues</a>
            <a href="https://github.com/broadinstitute/TRExplorer" target="_blank" id="github-icon"><i class="github icon"></i></a>
        </div>
        <div class="three wide column" class="page-grid-margin" style="padding: 0px !important"></div>
    </div>

    <div class="ui row" id="igv-row">
        <div class="sixteen wide column">
            <div id="igv-viewport"></div>
        </div>
    </div>

    <div class="ui row">
        <div class="three wide column"></div>
        <div class="ten wide column">
            <div id="show-igv-divider">
                <span id="show-igv-divider-text">Show IGV.js<i class="chevron down icon"></i></span>
                <span id="hide-igv-divider-text" style="display: none">Hide IGV.js<i class="chevron up icon"></i></span>
            </div>
        </div>
        <div class="three wide column"></div>
    </div>
    <div class="ui row">
        <div class="one wide column"></div>
        <div class="fourteen wide column">
            <!-- Results Area -->
            <div id="results-title"></div>
            <div id="results-area" style="position: relative; z-index: 100;"></div>
        </div>
        <div class="one wide column"></div>
    </div>
</div>

<script>

    $('body').css('cursor', 'wait')

    const REQUIRED_DATA_COLUMNS_FOR_POLYMORPHISM_COLUMN = [
        'AoU1027_Stdev',
        'StdevFromIllumina174k',
        'AlleleFrequenciesFromIllumina174k',
        'StdevFromT2TAssemblies',
        'AlleleFrequenciesFromT2TAssemblies',
        'ReferenceRegion',
        'NumRepeatsInReference',
        'ReferenceMotif',
        'HPRC100_Stdev',
        'HPRC100_AlleleHistogram',
        'HPRC100_BiallelicHistogram',
        'AoU1027_Stdev',
        'TenK10K_AlleleHistogram',
        'TenK10K_BiallelicHistogram',
        'TenK10K_Stdev',
        'AoU1027_OE_LengthPercentile',
    ]

    // persistent page state (added to the URL)
    let DEFAULT_GLOBAL_PAGE_STATE = {

        locusId: '',

        showIGV: 0,
        igvLoc: 'chr4:3074821-3074990',

        // Custom track URLs
        igv_custom_track_url_1: '',
        igv_custom_track_url_2: '',
        igv_custom_track_url_3: '',
    }

    ALL_AVAILABLE_TRACKS.forEach((rt) => {
        DEFAULT_GLOBAL_PAGE_STATE[rt[0]] = 0
    })

    DEFAULT_GLOBAL_PAGE_STATE['igv_kd_loci'] = 1
    //DEFAULT_GLOBAL_PAGE_STATE['igv_tr_explorer_catalog_v2'] = 1

    //copy the default persistent page state
    let GLOBAL_PAGE_STATE = JSON.parse(JSON.stringify(DEFAULT_GLOBAL_PAGE_STATE))



    const readAndApplyPersistentPageStateFromUrl = async () => {
        GLOBAL_PAGE_STATE = JSON.parse(JSON.stringify(DEFAULT_GLOBAL_PAGE_STATE))
        
        const hash = window.location.hash.substring(1)
        if (!hash) return
        
        const params = new URLSearchParams(hash)
        
        for (const [key, value] of params.entries()) {
            if (key in DEFAULT_GLOBAL_PAGE_STATE && value != null) {
                // Convert string values to appropriate types
                GLOBAL_PAGE_STATE[key] = value === 'true' ? true : 
                                        value === 'false' ? false :
                                        !isNaN(value) ? Number(value) : value
                if (key === 'showColumns') {
                    GLOBAL_PAGE_STATE['showColumns'] = `${value}` // convert to string
                }
            }
        }
        console.log("Starting to initialize page. GLOBAL_PAGE_STATE:", GLOBAL_PAGE_STATE)


        // igv
        if (GLOBAL_PAGE_STATE['showIGV'] === 1) {
            $('#igv-row').show()
            $('#show-igv-divider-text').hide()
            $('#hide-igv-divider-text').show()
            await updateIgv()
        }

        // advanced search wrapper
        if (GLOBAL_PAGE_STATE['showAdvFilters'] === 1) {
            $('#advanced-search-form').show()
            $('#filter-button .filter.icon').removeClass('rotated')
        }

        // Restore custom track URLs
        for (let i = 1; i <= 3; i++) {
            $(`#igv-custom-track-url-${i}`).val(GLOBAL_PAGE_STATE[`igv_custom_track_url_${i}`] || '')
        }

        await performSearch()
        
    }

    const writePersistentPageStateToUrl = () => {
        // Create object with only non-default values
        const nonDefaultParams = {}
        for (const [key, value] of Object.entries(GLOBAL_PAGE_STATE)) {
            if (value !== DEFAULT_GLOBAL_PAGE_STATE[key]) {
                nonDefaultParams[key] = value
            }
        }

        // Convert to URL hash using jQuery's param method
        const hash = '#' + $.param(nonDefaultParams)

        // Get current hash to check if state has changed
        const currentHash = window.location.hash
        if (currentHash !== hash) {
            // Update URL and add to browser history
            window.history.pushState(null, '', hash)
        }
    }

    const generateIgvConfig = (addSelectedTracks) => {

        // specify IGV tracks and the data to display in them
        const tracks = []


        if (addSelectedTracks) {
            tracks.push({
                name: "Refseq",
                format: "refgene",
                url: `${REFERENCE_BASE_URL}/ncbiRefSeq.txt.gz`,
                indexed: true,
                indexURL: `${REFERENCE_BASE_URL}/ncbiRefSeq.txt.gz.tbi`,
                infoURL: "https://www.ncbi.nlm.nih.gov/gene/?term=$$",
                height: 150,
            })

            ALL_AVAILABLE_TRACKS.forEach((rt) => {
                const trackName = rt[0]
                const trackDisplayName = rt[1]
                const trackURL = rt[2]
                if (!GLOBAL_PAGE_STATE[trackName]) {
                    return
                }

                if (trackName == 'igv_gencode') {
                    tracks.push({
                        name: trackDisplayName,
                        format: 'refgene',
                        url: trackURL,
                        indexURL: `${trackURL}.tbi`,
                        indexed: true,
                        searchable: true,
                        height: 350,
                        visibilityWindow: -1,
                        displayMode: 'EXPANDED',
                        color: 'rgb(76,171,225)',
                    })
                } else if (trackURL.endsWith('.bed.gz')) {
                    tracks.push({
                        format: 'bed',
                        name: trackDisplayName,
                        url: trackURL,
                        indexURL: `${trackURL}.tbi`,
                        indexed: true,
                        searchable: false,
                        displayMode: 'EXPANDED',
                    })
                } else if (trackURL.endsWith('.gtf.gz')) {
                    tracks.push({
                        format: 'gtf',
                        name: trackDisplayName,
                        url: trackURL,
                        indexed: true,
                        searchable: false,
                        displayMode: 'EXPANDED',
                    })
                } else {
                    tracks.push({
                        name: trackDisplayName,
                        url: trackURL,
                    })
                }

            })

            // Add custom tracks if they have URLs
            for (let i = 1; i <= 3; i++) {
                const url = GLOBAL_PAGE_STATE[`igv_custom_track_url_${i}`]
                if (url && url.trim() !== '') {
                    tracks.push({
                        name: url.split('/').pop(),
                        url: url.trim()
                    })
                }
            }
        }

        const reference = {
            "id": "hg38",
            "name": "Human (GRCh38/hg38)",
            "fastaURL": "https://igv-genepattern-org.s3.amazonaws.com/genomes/seq/hg38/hg38.fa",
            "indexURL": "https://igv-genepattern-org.s3.amazonaws.com/genomes/seq/hg38/hg38.fa.fai",
            "cytobandURL": "https://s3.amazonaws.com/igv.org.genomes/hg38/annotations/cytoBandIdeo.txt.gz",
            "aliasURL": "https://s3.amazonaws.com/igv.org.genomes/hg38/hg38_alias.tab",
            "chromosomeOrder": "chr1, chr2, chr3, chr4, chr5, chr6, chr7, chr8, chr9, chr10, chr11, chr12, chr13, chr14, chr15, chr16, chr17, chr18, chr19, chr20, chr21, chr22, chrX, chrY",
            "tracks": tracks,
        }

        const locus = GLOBAL_PAGE_STATE['igvLoc']
        return {
            reference: reference,
            showCursorTrackingGuide: true,
            minimumBases: 40,  //required for https://github.com/igvteam/igv.js/issues/2046
            locus: locus,
        }
    }

    async function updateIgv() {

        // create igv.js browser object if it hasn't been created yet
        if (!window.igvBrowser) {
            const config = generateIgvConfig(false)
            window.igvBrowser = await igv.createBrowser(document.getElementById("igv-viewport"), config)

            //window.igvBrowser.trackViews.forEach((trackView) => { monkeyPatchPopupData(trackView.track) }
            window.igvBrowser.on('trackremoved', (track) => {
                // get the track id that matches the url
                ALL_AVAILABLE_TRACKS.forEach((rt) => {
                    if (track.url === rt[2]) {
                        const trackName = rt[0]
                        $(`input[name="${trackName}"]`).prop('checked', false)
                        GLOBAL_PAGE_STATE[trackName] = 0
                        writePersistentPageStateToUrl()
                    }
                })
            })

            window.igvBrowser.on('locuschange', (locus) => {
                if (locus[0] && locus[0].chr && locus[0].start && locus[0].end) {
                    GLOBAL_PAGE_STATE['igvLoc'] = `${locus[0].chr}:${parseInt(locus[0].start)}-${parseInt(locus[0].end)}`
                    writePersistentPageStateToUrl()
                }
            })

            // add the IGV tracks selection button
            $($('#igv-viewport')[0].shadowRoot).find('.igv-navbar-left-container').after(
            //$('.igv-navbar-left-container').after(
                `<button id="igv-select-tracks-button" class="ui primary basic button" style="height:25px; padding:2px 15px 2px 30px; border-color:#06359d !important; border-width: 1px !important; border-radius:5px; color:#06359d !important; background-color: white !important; cursor: pointer;">
                   Select IGV Tracks
                   <i class="setting icon" style="margin-left:10px" />
                </button>`
            )

            $('#igv-tr-explorer-catalog-tracks-checkboxes').html($('#igv-tr-explorer-catalog-tracks-checkboxes').html() +
                TR_EXPLORER_CATALOG.map((rt) => `
                    <tr><td>
                        <div class="inline-field"><div class="ui checkbox igv-track-checkbox"><input type="checkbox" name="${rt[0]}" ${GLOBAL_PAGE_STATE[rt[0]] ? 'checked' : ''}><label>${rt[1]}</label></div> ${rt[4] ? '<i class="question circle icon link" data-html="' + rt[4] + '" ></i>' : ''}
                    </td><td class="igv-number-of-loci-column">
                         ${rt[3].toLocaleString()}
                    </td></tr>
                `).join(' ') + `
                    <tr>
                        <td style="padding: 5px 0px !important">
                            <i>Source Catalogs:</i>
                            <i class="question circle icon link" style="margin-left: 15px;" data-html="These 4 catalogs were merged to create the TRExplorer Catalog. For more details, see [<a href='https://www.biorxiv.org/content/10.1101/2024.10.04.615514v1' target=_blank>Weisburd, Dolzhenko et al. 2024</a>]."></i>
                        </td>
                        <td></td>
                    </tr>
                ` +
                TR_EXPLORER_SOURCE_CATALOGS.map((rt) => `
                    <tr><td><div class="ui checkbox igv-track-checkbox" style="margin-left: 30px !important; display: inline-block"><input type="checkbox" name="${rt[0]}" ${GLOBAL_PAGE_STATE[rt[0]] ? 'checked' : ''}><label>${rt[1]}</label></div>${rt[4] ? '<i class="question circle icon link" data-html="' + rt[4] + '"></i>' : ''}</td><td class="igv-number-of-loci-column">${rt[3].toLocaleString()}</td></tr>
                `).join(' '))

            $('#igv-variation-cluster-tracks-checkboxes').html($('#igv-variation-cluster-tracks-checkboxes').html() +
                TR_VARIATION_CLUSTERS.map((rt) => `
                    <tr><td><div class="ui checkbox igv-track-checkbox" style="display: inline-block"><input type="checkbox" name="${rt[0]}" ${GLOBAL_PAGE_STATE[rt[0]] ? 'checked' : ''}><label>${rt[1]}</label></div>${rt[4] ? '<i class="question circle icon link" data-html="' + rt[4] + '"></i>' : ''}</td><td class="igv-number-of-loci-column">${rt[3].toLocaleString()}</td></tr>
                `).join(' ')
            )

            $('#igv-other-tr-catalog-tracks-checkboxes').html($('#igv-other-tr-catalog-tracks-checkboxes').html() +
                GENOME_WIDE_TR_CATALOGS.map((rt) => `
                    <tr><td><div class="ui checkbox igv-track-checkbox" style="display: inline-block"><input type="checkbox" name="${rt[0]}" ${GLOBAL_PAGE_STATE[rt[0]] ? 'checked' : ''}><label>${rt[1]}</label></div>${rt[4] ? '<i class="question circle icon link" data-html="' + rt[4] + '"></i>' : ''}</td><td class="igv-number-of-loci-column">${rt[3].toLocaleString()}</td></tr>
                `).join(' ')
            )

            $('#igv-known-disease-loci-checkboxes').html($('#igv-known-disease-loci-checkboxes').html() +
                KNOWN_TR_LOCI_TRACK.map((rt) => `
                    <tr><td><div class="ui checkbox igv-track-checkbox" style="display: inline-block"><input type="checkbox" name="${rt[0]}" ${GLOBAL_PAGE_STATE[rt[0]] ? 'checked' : ''}><label>${rt[1]}</label></div>${rt[4] ? '<i class="question circle icon link" data-html="' + rt[4] + '"></i>' : ''}</td><td class="igv-number-of-loci-column">${rt[3].toLocaleString()}</td></tr>
                `).join(' ')
            )

            $('#igv-reference-tracks-checkboxes').html($('#igv-reference-tracks-checkboxes').html() +
                `<tr><td>` +
                REFERENCE_TRACKS.map((rt) => `
                    <div class="ui checkbox igv-track-checkbox"><input type="checkbox" name="${rt[0]}" ${GLOBAL_PAGE_STATE[rt[0]] ? 'checked' : ''}><label>${rt[1]}</label></div>
                `).join(' ')
                + `</td></tr>`
            )

            $('#igv-custom-tracks').html($('#igv-custom-tracks').html() +
                `<tr>
                    <td colspan="2">
                        <input type="text" style="margin-bottom: 10px; width:100%;" class="igv-custom-track-url" id="igv-custom-track-url-1" placeholder="Enter a public data file URL for custom track #1. It can be an indexed BED, BAM, VCF, or other file format supported by IGV.js" />
                        <input type="text" style="margin-bottom: 10px; width:100%;" class="igv-custom-track-url" id="igv-custom-track-url-2" placeholder="Enter a public data file URL for custom track #2. It can be an indexed BED, BAM, VCF, or other file format supported by IGV.js" />
                        <input type="text" style="margin-bottom: 10px; width:100%;" class="igv-custom-track-url" id="igv-custom-track-url-3" placeholder="Enter a public data file URL for custom track #3. It can be an indexed BED, BAM, VCF, or other file format supported by IGV.js" />
                    </td>
                </tr>`
            )

            $(".ui.checkbox").checkbox()

            $($('#igv-viewport')[0].shadowRoot).find('#igv-select-tracks-button').click(() => {
            //$('#igv-select-tracks-button').click(() => {
                ALL_AVAILABLE_TRACKS.forEach((rt) => {
                    const trackName = rt[0]
                    const isChecked = GLOBAL_PAGE_STATE[trackName] === 1
                    $(`input[name="${trackName}"]`).prop('checked', isChecked)
                })

                $('#igv-track-selection-dialog').modal('show')
                $('.question').popup({ on: 'click' })
            })
            $('#igv-tracks-modal-apply-button').click(async() => {
                // update GLOBAL_PAGE_STATE with selected tracks
                ALL_AVAILABLE_TRACKS.forEach((rt) => {
                    const trackName = rt[0]
                    const isChecked = $(`input[name="${trackName}"]`).is(':checked')
                    GLOBAL_PAGE_STATE[trackName] = isChecked ? 1 : 0
                })

                // update custom track URLs
                for (let i = 1; i <= 3; i++) {
                    const url = $(`#igv-custom-track-url-${i}`).val()
                    GLOBAL_PAGE_STATE[`igv_custom_track_url_${i}`] = url || ''
                }

                writePersistentPageStateToUrl()
                await updateIgv()
            })
        }

        if (GLOBAL_PAGE_STATE['showIGV'] === 1) {
            const igvConfig = generateIgvConfig(true)

            console.log("Updating igv config to", igvConfig)
            await window.igvBrowser.loadSessionObject(igvConfig)
        }
    }

    $('#show-igv-divider').click(async () => {
        GLOBAL_PAGE_STATE['showIGV'] = (GLOBAL_PAGE_STATE['showIGV'] === 1) ? 0 : 1
        writePersistentPageStateToUrl()

        if (GLOBAL_PAGE_STATE['showIGV'] === 1) {
            $('#igv-row').show()
            $('#show-igv-divider-text').hide()
            $('#hide-igv-divider-text').show()
            await updateIgv()
        } else {
            $('#igv-row').slideUp(500, () => {
                $('#hide-igv-divider-text').hide()
                $('#show-igv-divider-text').show()
            })
        }

    })

    const queryBigQuery = async (query, startIndex=null, pageSize=null, exportToFileFormat=null, toolName=null) => {
        try {
            const url = `https://us-central1-cmg-analysis.cloudfunctions.net/query_db`
            console.log("Page state:", GLOBAL_PAGE_STATE)
            console.log(exportToFileFormat ? `Exporting to ${exportToFileFormat}:`: `Sending query:`, query.replace(/[\n\r\s]+/g, ' '))
            const requestBody = {
                sql: query,
                export_to_file_format: exportToFileFormat,
                tool_name: toolName,
                start_index: startIndex,
                page_size: pageSize,
            }

            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody),
            })

            if (!response.ok) {
                throw new Error(`BigQuery API error: ${response.status} ${response.statusText}`)
            }

            return await response.json()
        } catch (error) {
            console.error('Error querying BigQuery:', error)
            throw new Error(`BigQuery query error: ${error.message || 'Unknown error'}`)
        }
    }

    const parseAlleleFrequenciesString = (frequenciesString) => {
        try {
            const data = []
            const items = frequenciesString.split(',')
            for (let i = 0; i < items.length; i++) {
                const [size, count] = items[i].split(':')
                data.push({
                    size: parseInt(size.replace('x', '')),
                    count: parseInt(count)
                })
            }
            return data
        } catch (e) {
            console.error('Error parsing allele frequencies string:', e)
            return []
        }
    }

    const createAlleleFrequencyChart = (chartData) => {
        const frequencies = chartData.frequencies
        const thisObj = chartData.thisObj
        const refAlleleSize = chartData.refAlleleSize
        const chartWidth = chartData.chartWidth
        const chartHeight = chartData.chartHeight
        const minAlleleSize = chartData.minAlleleSize
        const maxAlleleSize = chartData.maxAlleleSize

        const chartLabel = chartData.label

        //frequencies.sort((a, b) => a.size - b.size)

        const yLookup = {}
        const xLabels =  []
        const colors = []
        const borderColors = []
        for (let i = minAlleleSize - 1; i <= maxAlleleSize + 1; i++) {
            xLabels.push(i)
            yLookup[i] = 0
        }
        for (let x of xLabels) {
            yLookup[x] = frequencies.find(f => f.size === x)?.count || 0
            colors.push(x === refAlleleSize ? 'rgba(255, 165, 0, 0.7)' : 'rgba(33, 133, 208, 0.5)')
            borderColors.push(x === refAlleleSize ? 'rgba(255, 165, 0, 1)' : 'rgba(33, 133, 208, 1)')
        }

        // Destroy any existing chart on this canvas
        const existingChart = Chart.getChart(thisObj);
        if (existingChart) {
            existingChart.destroy();
        }


        //set y-limit to the nearest whole power of 10 divided by 2, rounding up
        const yLimit = Math.pow(10, Math.ceil(Math.log10(2 * Math.max(...frequencies.map(f => f.count))))) / 2
        new Chart(thisObj, {
            type: 'bar',
            data: {
                labels: xLabels,
                datasets: [{
                    data: xLabels.map(d => yLookup[d]),
                    backgroundColor: colors,
                    borderColor: borderColors,
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    legend: {
                        display: true,
                        align: 'end',
                        labels: {
                            boxWidth: 10,
                            boxHeight: 10,
                            padding: 5,
                            font: {
                                size: 12
                            },
                            generateLabels: function(chart) {
                                return [{
                                    text: `Ref. Allele: ${refAlleleSize} repeats`,
                                    fillStyle: 'rgba(255, 165, 0, 0.7)',
                                    strokeStyle: 'rgba(255, 165, 0, 1)',
                                    lineWidth: 1,
                                    hidden: false,
                                    index: 0
                                }]
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Count: ${context.raw}`
                            }
                        },
                        position: 'nearest',
                        yAlign: 'bottom'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Repeat Count',
                            font: {
                                size: 13
                            },
                        },
                        ticks: {
                            font: {
                                size: 13
                            },
                        }
                    },
                    y: {
                        type: 'logarithmic',
                        min: 0,
                        max: parseInt(yLimit),
                        title: {
                            display: true,
                            text: '# of alleles',
                            font: {
                                size: 13
                            },
                        },
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (Math.floor(value) === value) {
                                    return parseInt(value)
                                }
                            },
                            font: {
                                size: 13
                            },
                        },
                        afterBuildTicks: (axis) => {
                            const ticks = [0, 3, 10, 30, 100, 300, 1000, 3000, 10000]
                            axis.ticks = ticks.filter(t => t <= axis.max).map(t => ({value: t}))
                        }
                    }
                }
            }
        })

        thisObj.style.minWidth = chartWidth

        thisObj.style.height = chartHeight
        thisObj.style.minHeight = chartHeight
        thisObj.style.maxHeight = chartHeight
    }

    const parseBiallelicHistogramString = function(frequenciesString) {
        // example: frequencies = "2/2:58,2/3:34,3/3:4"
        const data = []
        const lookup = {}
        const items = frequenciesString.split(',')
        for (let i = 0; i < items.length; i++) {
            try {
                const value = items[i].split(':')
                const genotype = value[0].split('/')
                const allele1 = parseInt(genotype[0])
                const allele2 = parseInt(genotype[1])
                const shortAlleleSize = Math.min(allele1, allele2)
                const longAlleleSize = Math.max(allele1, allele2)
                const count = parseInt(value[1])
                data.push({ x: longAlleleSize, y: shortAlleleSize, v: count})
                lookup[`${shortAlleleSize}/${longAlleleSize}`] = count
            } catch (e) {
                console.error('Error parsing biallelic histogram string:', e)
                return [[], {}]
            }
        }

        return [data, lookup]
    }

    const createBiallelicHistogramChart = (chartData) => {
        let data = chartData.data
        let lookup = chartData.lookup
        const thisObj = chartData.thisObj
        const refAlleleSize = chartData.refAlleleSize
        const chartWidth = chartData.chartWidth
        const chartHeight = chartData.chartHeight
        const minAlleleSize = chartData.minAlleleSize - 1
        const maxAlleleSize = chartData.maxAlleleSize + 1

        // Find the range of allele sizes
        const allShortAlleles = data.map(d => d.y)
        const allLongAlleles = data.map(d => d.x)

        // Calculate bin size if range exceeds 30
        const maxBins = 20
        const needsBinning = (maxAlleleSize - minAlleleSize) > maxBins
        const binSize = needsBinning ? Math.ceil((maxAlleleSize - minAlleleSize) / maxBins) : 1

        // Create labels for both axes
        const shortAlleleLabels = []
        const longAlleleLabels = []

        // Create binned or regular labels
        for (let i = Math.max(0, minAlleleSize - binSize); i <= maxAlleleSize + binSize; i += binSize) {
            const binEnd = i + binSize
            const label = needsBinning ? `${i}-${binEnd}` : i
            shortAlleleLabels.push(label)
            longAlleleLabels.push(label)
        }

        if (needsBinning) {
            data = []
            for (const shortAlleleLabel of shortAlleleLabels) {
                for (const longAlleleLabel of longAlleleLabels) {
                    let binCount = 0
                    const shortAlleleStart = parseInt(shortAlleleLabel.split('-')[0])
                    const shortAlleleEnd = parseInt(shortAlleleLabel.split('-')[1])
                    const longAlleleStart = parseInt(longAlleleLabel.split('-')[0])
                    const longAlleleEnd = parseInt(longAlleleLabel.split('-')[1])
                    for (let short = shortAlleleStart; short < shortAlleleEnd; short++) {
                        for (let long = longAlleleStart; long < longAlleleEnd; long++) {
                            const value = lookup[`${short}/${long}`]
                            if (value) {
                                binCount += value
                            }
                        }
                    }
                    data.push({x: longAlleleLabel, y: shortAlleleLabel, v: binCount})
                }
            }

            lookup = {}
            for (const d of data) {
                if (d.v > 0) {
                    lookup[`${d.y}/${d.x}`] = d.v
                }
            }
        }

        // Calculate maxCount from the binned data
        const maxCount = Math.max(...data.map(d => d.v))

        // Destroy any existing chart
        const existingChart = Chart.getChart(thisObj)
        if (existingChart) {
            existingChart.destroy()
        }

        // Create the chart
        new Chart(thisObj, {
            type: 'matrix',
            data: {
                datasets: [{
                    data: data,
                    backgroundColor: function(context) {
                        const value = context.dataset.data[context.dataIndex].v
                        if (value === 0) return 'rgba(255, 255, 255, 0)'
                        const alpha = Math.pow(value / maxCount, 0.5)  // Square root to make small values more visible
                        return `rgba(33, 133, 208, ${alpha})`
                    },
                    borderColor: 'rgba(0, 0, 0, 0.5)',
                    borderWidth: function(context) {
                        const value = context.dataset.data[context.dataIndex].v
                        if (value === 0) return 0
                        return 1
                    }
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                    x: {
                        type: 'category',
                        offset: false,  // Remove offset to center labels
                        labels: longAlleleLabels,
                        title: {
                            display: true,
                            text: 'Long allele (repeats)',
                            font: {
                                size: 12
                            }
                        },
                        grid: {
                            display: true
                        }
                    },
                    y: {
                        type: 'category',
                        offset: false,  // Remove offset to center labels
                        reverse: true,  // Reverse y-axis
                        labels: shortAlleleLabels,
                        title: {
                            display: true,
                            text: 'Short allele (repeats)',
                            font: {
                                size: 12
                            }
                        },
                        grid: {
                            display: true
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        displayColors: false,
                        callbacks: {
                            title: function(context) {
                                const c = context[0]
                                const value = c.dataset.data[c.dataIndex].v
                                if (value === 0) return ''
                                const shortLabel = shortAlleleLabels[c.parsed.y]
                                const longLabel = longAlleleLabels[c.parsed.x]
                                // if it's a bin, show the range
                                if (typeof shortLabel === 'string' && typeof longLabel === 'string' && shortLabel.includes('-') && longLabel.includes('-')) {
                                    const shortStart = parseInt(shortLabel.split('-')[0])
                                    const shortEnd = parseInt(shortLabel.split('-')[1])
                                    const longStart = parseInt(longLabel.split('-')[0])
                                    const longEnd = parseInt(longLabel.split('-')[1])
                                    return `Genotype Bin:\n${longStart} ≤ long  allele < ${longEnd}\n${shortStart} ≤ short allele < ${shortEnd}`
                                } else {
                                    return `Genotype: ${shortLabel}/${longLabel}`
                                }
                            },
                            label: function(context) {
                                const c = context
                                const value = c.dataset.data[c.dataIndex].v
                                if (value === 0) return null
                                const shortLabel = shortAlleleLabels[c.parsed.y]
                                const longLabel = longAlleleLabels[c.parsed.x]
                                const genotype = `${shortLabel}/${longLabel}`
                                return `Individuals: ${lookup[genotype] || 0}`
                            }
                        }
                    },
                    legend: {
                        display: false
                    }
                }
            }
        })

        thisObj.style.minWidth = chartWidth
        thisObj.style.height = chartWidth
        thisObj.style.minHeight = chartWidth
        thisObj.style.maxHeight = chartWidth
    }

    const createSmallAlleleFrequencyChart = function() {
        const frequencies = $(this).data('frequencies')
        const refAlleleSize = $(this).data('ref-allele-size')

        if (!frequencies) return   // Skip if no data

        const data = parseAlleleFrequenciesString(frequencies)

        const yLookup = {}
        const xLabels =  []
        const colors = []
        const borderColors = []
        for (let i = Math.min(...data.map(d => d.size)) - 1; i <= Math.max(...data.map(d => d.size)) + 1; i++) {
            xLabels.push(i)
            yLookup[i] = 0
        }
        for (let x of xLabels) {
            yLookup[x] = data.find(d => d.size === x)?.count || 0
            colors.push(x === refAlleleSize ? 'rgba(255, 165, 0, 0.7)' : 'rgba(33, 133, 208, 0.5)')
            borderColors.push(x === refAlleleSize ? 'rgba(255, 165, 0, 1)' : 'rgba(33, 133, 208, 1)')
        }

        //set y-limit to the nearest whole power of 10 divided by 2, rounding up
        const yLimit = Math.pow(10, Math.ceil(Math.log10(2 * Math.max(...data.map(d => d.count))))) / 2
        new Chart(this, {
            type: 'bar',
            data: {
                labels: xLabels,
                datasets: [{
                    data: xLabels.map(d => yLookup[d]),
                    backgroundColor: colors,
                    borderColor: borderColors,
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Count: ${context.raw}`
                            }
                        },
                        position: 'nearest',
                        yAlign: 'bottom'
                    }
                },
                scales: {
                    y: {
                        type: 'logarithmic',
                        min: 0,
                        max: parseInt(yLimit),
                        beginAtZero: true,
                        ticks: {
                            font: {
                                size: 10
                            },
                            callback: function(value) {
                                if (Math.floor(value) === value) {
                                    return parseInt(value)
                                }
                            },
                            padding: 3,
                        },
                        grid: {
                            drawTicks: false
                        }

                    },
                    x: {
                        ticks: {
                            font: {
                                size: 10
                            },
                            padding: 3
                        },
                        grid: {
                            drawTicks: false
                        }
                    }
                }
            }
        })

        this.style.minHeight = '55px'
        this.style.maxHeight = '55px'
        this.style.minWidth = '100px'
        this.style.maxWidth = '200px'
        this.style.height = '55px'

        $(this).parent().css('padding-top', '0')
        $(this).parent().css('padding-bottom', '0')
    }


    const displayError = (message) => {
        $('#error-text').text(message)
        $('#error-message').show()
        $('#results-table').empty()
    }

    const displaySearchResults = () => {
        // display the search results in the results-table div

        const row = window.searchResults.rows[0]
        console.log("search results row:", row)

        for (const key of REQUIRED_DATA_COLUMNS_FOR_POLYMORPHISM_COLUMN) {
            const lowerCaseKey = key.toLowerCase()
            if (row[lowerCaseKey] != null) {
                row[key] = row[lowerCaseKey]
            }
        }

        $('#results-title').html(`<h3 style="text-align: center">${row.ReferenceMotif} repeats &nbsp; @ &nbsp; ${row.ReferenceRegion}</h3><br />`)
        $('#results-area').html('')

        const stdevColumns = ['HPRC100_Stdev', 'AoU1027_Stdev', 'TenK10K_Stdev', 'StdevFromIllumina174k', 'StdevFromT2TAssemblies']
        const alleleFrequencyColumns = ['HPRC100_AlleleHistogram', 'TenK10K_AlleleHistogram', 'AlleleFrequenciesFromIllumina174k', 'AlleleFrequenciesFromT2TAssemblies']

        const nStdevsNotAvailable = [row.HPRC100_Stdev == null, row.AoU1027_Stdev == null, row.TenK10K_Stdev == null, row.StdevFromIllumina174k == null, row.StdevFromT2TAssemblies == null].filter(Boolean).length

        let polymorphismDialogContent = `
            <div class="content" style="text-align: center">
        `

        if (nStdevsNotAvailable == stdevColumns.length) {
            polymorphismDialogContent += `
                    <span style="color: #686868;">No polymorphism data available.</span>
                    <br /><br />
            `
        } else {
            polymorphismDialogContent += `
                <div><span style="font-weight: bold">Allele Frequency Distribution Summary Statistics</span></div>
                    <div style="margin-top: 5px">
                        <table style="margin: 0 auto">
            `
        }

        for (const key of stdevColumns) {
            if (row[key] != null) {
                polymorphismDialogContent += `
                    <tr>
                        <td style="text-align: left;">
                            <span style="font-size: 1.2em;">σ<sub style="font-size: 0.7em;">${STDEV_SIGMA_SUBSCRIPTS[key]}</sub></span>
                        </td>
                        <td style="text-align: right;">
                            = ${row[key].toFixed(3)}
                        </td>
                        <td style="text-align: right;">
                            <i class="question circle icon link" style="margin-left: 15px;" data-html="${STDEV_HELP_TEXTS[key]}"></i>
                        </td>
                    </tr>
                `
            }
        }
        polymorphismDialogContent += "</table>"

        if (nStdevsNotAvailable > 0) {
            polymorphismDialogContent += "<br />"
            let namesOfMissingSigmas = []
            for (const key of stdevColumns) {
                if (row[key] == null) {
                    namesOfMissingSigmas.push(`<span style="font-size: 1.2em;">σ<sub style="font-size: 0.7em;">${STDEV_SIGMA_SUBSCRIPTS[key]}</sub></span>`)
                }
            }
            polymorphismDialogContent += ` ${namesOfMissingSigmas.join(' &amp; ')} ${namesOfMissingSigmas.length > 1 ? 'are' : 'is'} not available for this locus`
        }

        if (row.AoU1027_OE_LengthPercentile != null) {
            polymorphismDialogContent += `
                <div style="margin-top: 25px">
                    Constraint (O/E Length) percentile = ${((100*row.AoU1027_OE_LengthPercentile).toFixed(1))}% <i class="question circle icon link" style="margin-left: 15px;" data-html="${RESULTS_TABLE_COLUMN_HELP_TEXTS['AoU1027_OE_LengthPercentile']}"></i>
                </div>
            `
        }

        polymorphismDialogContent += "</div>"
        // check if any of the allele frequency columns are available
        const alleleFrequencyColumnsAvailable = alleleFrequencyColumns.some(column => row[column] != null)
        if (alleleFrequencyColumnsAvailable) {
            // calculate the height of the allele frequency charts
            polymorphismDialogContent += `
                <div style="margin-top: 15px;">
                    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px">
            `

            for (const column of alleleFrequencyColumns) {
                if (row[column] != null) {
                    polymorphismDialogContent += `

                        <div style="border-top: 1px dashed #ccc; padding: 23px 20px 15px 15px;">
                            <div style="margin-bottom: 5px;"><b>${ALLELE_FREQUENCY_CHART_TITLES[column]}</b><br /><span style="color: #686868;">${ALLELE_FREQUENCY_CHART_SUBTITLES[column]}</span></div>
                            <canvas class="allele-frequency-chart" data-label="${ALLELE_HISTOGRAM_SHORT_NAMES[column]}" data-frequencies-column="${column}" data-ref-allele-size="${row.NumRepeatsInReference}" data-chart-width="500px" data-chart-height="200px" style="width: 100%; height: 100px;"></canvas>
                        </div>
                    `
                }
            }
            polymorphismDialogContent += '</div></div>'
        }

        const biallelicHistogramColumns = ['HPRC100_BiallelicHistogram', 'TenK10K_BiallelicHistogram']
        const biallelicHistogramColumnsAvailable = biallelicHistogramColumns.some(column => row[column] != null)
        if (biallelicHistogramColumnsAvailable) {
            polymorphismDialogContent += `
                <div style="margin-top: 15px;">
                    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px">
            `
            for (const column of biallelicHistogramColumns) {
                if (row[column] != null) {
                    polymorphismDialogContent += `
                        <div style="border-top: 1px dashed #ccc; padding: 23px 20px 15px 15px;">
                            <div style="margin-bottom: 5px;"><b>${ALLELE_FREQUENCY_CHART_TITLES[column]}</b><br /><span style="color: #686868;">${ALLELE_FREQUENCY_CHART_SUBTITLES[column]}</span></div>
                            <canvas class="biallelic-histogram-chart" data-label="${ALLELE_HISTOGRAM_SHORT_NAMES[column]}" data-frequencies-column="${column}" data-ref-allele-size="${row.NumRepeatsInReference}" data-chart-width="500px" data-chart-height="200px" style="width: 100%; height: 100px;"></canvas>
                        </div>
                    `
                }
            }
            polymorphismDialogContent += '</div></div>'
        }

        $('#results-area').html(polymorphismDialogContent.replace(/\s+/g, ' ').trim())


        // prepare chart data
        let alleleFrequencyChartData = []
        $('.allele-frequency-chart').each(function() {
            const frequenciesColumn = $(this).data('frequencies-column')
            const frequenciesString = row[frequenciesColumn]
            if (!frequenciesString) return   // Skip if no data

            const frequencies = parseAlleleFrequenciesString(frequenciesString)

            alleleFrequencyChartData.push({
                frequencies: frequencies,
                thisObj: this,
                refAlleleSize: $(this).data('ref-allele-size'),
                chartWidth: $(this).data('chart-width'),
                chartHeight: $(this).data('chart-height'),
                label: $(this).data('label'),
                minAlleleSize: Math.min(...frequencies.map(f => f.size)),
                maxAlleleSize: Math.max(...frequencies.map(f => f.size))
            })
        })

        //compute overall min, max for all charts and then create the charts
        let overallMinAlleleSize = Math.min(...alleleFrequencyChartData.map(d => d.minAlleleSize))
        let overallMaxAlleleSize = Math.max(...alleleFrequencyChartData.map(d => d.maxAlleleSize))

        alleleFrequencyChartData.forEach((chartData) => {
            chartData.minAlleleSize = overallMinAlleleSize
            chartData.maxAlleleSize = overallMaxAlleleSize

            createAlleleFrequencyChart(chartData)
        })

        let biallelicHistogramChartData = []
        $('.biallelic-histogram-chart').each(function() {
            const frequenciesColumn = $(this).data('frequencies-column')
            let frequenciesString = row[frequenciesColumn]
            if (!frequenciesString) return   // Skip if no data

            let [data, lookup] = parseBiallelicHistogramString(frequenciesString)

            biallelicHistogramChartData.push({
                data: data,
                lookup: lookup,
                thisObj: this,
                refAlleleSize: $(this).data('ref-allele-size'),
                chartWidth: $(this).data('chart-width'),
                chartHeight: $(this).data('chart-height'),
                label: $(this).data('label'),
                minAlleleSize: Math.min(...data.map(f => Math.min(f.x, f.y))),
                maxAlleleSize: Math.max(...data.map(f => Math.max(f.x, f.y)))
            })
        })

        overallMinAlleleSize = Math.min(...biallelicHistogramChartData.map(d => d.minAlleleSize))
        overallMaxAlleleSize = Math.max(...biallelicHistogramChartData.map(d => d.maxAlleleSize))

        biallelicHistogramChartData.forEach((chartData) => {
            chartData.minAlleleSize = overallMinAlleleSize
            chartData.maxAlleleSize = overallMaxAlleleSize

            createBiallelicHistogramChart(chartData)
        })

        $('.question').popup({ on: 'click' })

    }

    const performSearch = async () => {
        // Remove any error messages and no results message
        $('#error-message').hide()
        $('#loading-container').show()      // Show loading indicator
        
        try {
            $('body').css('cursor', 'wait')

            let conditions = []

            let locusId = GLOBAL_PAGE_STATE['locusId']
            if (locusId) {
                conditions.push(`LocusId = '${locusId}'`)
            } else {
                displayError('Missing locusId URL parameter')
                return
            }

            //get all required columns for the visible columns
            let selectedColumns = [
                'LocusId',
                'ReferenceRegion',
                'DiseaseInfo',
                ...REQUIRED_DATA_COLUMNS_FOR_POLYMORPHISM_COLUMN,
            ]

            const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : ''

            const querySuffix = `\`${PROJECT_ID}.${DATASET_ID}.${TABLE_ID}\` ${whereClause}`
            const query = `SELECT ${selectedColumns.join(', ')} FROM ${querySuffix}`

            window.searchResults = await queryBigQuery(query, 0, 1, null, null)

            console.log("search results:", window.searchResults)
            // Remove loading indicator and placeholder before showing results
            $('#loading-container').hide()

            displaySearchResults()

        } catch (error) {
            console.error('Error performing search:', error)
            $('#loading-container').hide()
            displayError('Error performing search: ' + error.message)
        } finally {
            $('body').css('cursor', 'default')
            $('#results-table').show()
            $('#results-table').removeClass('loading')
        }
    }

    // initialize the "What's new", "FAQ", "Downloads", and "About" modals
    ['whats-new', 'faq', 'downloads', 'about'].forEach(prefix => {
        $(`#${prefix}-link`).click((e) => {
            e.preventDefault()
            $(`#${prefix}-modal`).modal('show')
        })
    })

    // handle browser forward & back buttons
    window.addEventListener('popstate', readAndApplyPersistentPageStateFromUrl)

    // init ui elements
    $('.ui.button').popup()
    $(".ui.checkbox").checkbox()


    $(document).ready(async () => {

        await readAndApplyPersistentPageStateFromUrl()

        console.log("Done initializing page. GLOBAL_PAGE_STATE:", GLOBAL_PAGE_STATE)
        $('body').css('cursor', 'default')
    })

</script>

</body>
</html>
